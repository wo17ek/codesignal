Your boss wants to identify the successful projects running in your company, so he asked you to prepare a list of all the currently active projects and their average monthly income.
You have stored the information about these projects in a simple database with a single Projects table that has five columns:
internal_id: the company's internal identifier for the project;
project_name: the official name of the project;
team_size: the number of employees working on the project;
team_lead: the name of the project manager;
income: the average monthly income of the project.
Your boss says that internal project ids are irrelevant to him and that he isn't interested in how big the teams are. 
Since that's the case, he wants you to create another table by removing the internal_id and team_size columns from the existing Projects table. 
Return it sorted by internal_id in ascending orde

						CREATE PROCEDURE projectList()
						BEGIN
							SELECT project_name, team_lead, income FROM Projects ORDER BY internal_id;
						END
						
Your friend wants to become a professional tour guide and travel all around the world. 
In pursuit of this dream, she enrolled in tour guide school. The professors in this school turned out to be very demanding, 
and one of them gave your friend a difficult assignment that she has to finish over the weekend.
Here's the assignment: Given a list of countries, your friend should identify all the countries that are in Africa. To help her, 
you have decided to write a function that will find all such countries from any set of countries. 
The countries table in which the countries are stored has the following structure:
name: the name of the country;
continent: the continent on which the country is situated;
population: the country's population.
Your task is to return a new table that has the same columns, but that only contains the countries from Africa. 
The countries should be sorted alphabetically by their names.

						CREATE PROCEDURE countriesSelection()
						BEGIN
							SELECT * FROM countries WHERE continent = "Africa";
						END
						
Students at your university get scholarships that are paid out throughout the year.
Information about the scholarships is stored in the table scholarships, which has the structure:
id: the unique student id;
scholarship: the amount of the annual scholarship the student has been awarded.
Now you need to calculate the amount of money each student should get per month. Given the table scholarships, 
build the resulting table as follows: The table should have the same columns as the initial table, 
but the scholarship column should contain the amount of the student's monthly scholarship payout. 
The rows should be ordered by the students' ids.

						CREATE PROCEDURE monthlyScholarships()
						BEGIN
							SELECT id, scholarship / 12 AS scholarship FROM scholarships;
						END
						
You've been promoted and assigned to a new project. 
The problem is, you don't know who you are working with and your predecessor has vanished without a trace!
Luckily, each project in your company keeps its own activity database, which you are going to use to find out the names of your new colleagues.
Information about the project's activity is stored in table projectLog, which has the following structure:
id: unique action id;
name: the name of the person who performed the action;
description: the description of the action;
timestamp: the timestamp of the action.
You only have access to the project's most recent history, but this should be enough for you. 
You've decided that finding everyone who interacted with the project in this period is the best way to start.
Given the table projectLog, build a new results table with a single name column that contains the 
names of the project's contributors sorted in ascending order.

						CREATE PROCEDURE projectsTeam()
						BEGIN
							SELECT name FROM projectLog
							GROUP BY name;
						END
						
The application you've been working on for the past year is a huge success! 
It already has a large and active user community. You know the ID number, username, and email of each user. 
Each user also has a specific role that shows their position in the community. Information about the users is stored in the database as a table users,
which has the following structure:
id: the unique user ID;
username: the username of the user;
role the user's role;
email: the user's email.
You want to send users automatic notifications to let them know about the most recent updates. However, 
not all users should get these notifications: Administrators don't need notifications since they know about the updates already, 
and premium users don't need them since they get personalized weekly updates.
Given the users table, your task is to return the emails of all the users who should get notifications, 
i.e. those whose role is not equal to "admin" or "premium". Note that roles are case insensitive, 
so users with roles of "Admin", "pReMiUm", etc. should also be excluded.
The resulting table should contain a single email column and be sorted by emails in ascending order.

						CREATE PROCEDURE automaticNotifications()
							SELECT email
							FROM users
							WHERE role NOT IN ("admin", "premium")

							ORDER BY email;
							
You are creating a website that will help you and your friends keep track of the results of volleyball teams from all around the world. 
Your website regularly crawls the web searching for new games, and adds the results of these games to the results table stored in your local database. 
After each update, the table should be sorted in ascending order by the total number of games won. This year's results are quite marvelous - at any given moment there are no two teams that have won the same number of games!
The results table contains the following columns:
name - the unique name of the team;
country - the country of the team;
scored - the number of scored goals;
missed - the number of missed goals;
wins - the total number of games the team has won.
Your task is to sort the given results table in ascending order by the number of wins.

						CREATE PROCEDURE volleyballResults()
						BEGIN
							SELECT * FROM results ORDER BY wins asc;
						END
						
Mr. Cash wants to keep track of his expenses, so he has prepared a list of all the products he bought this month. Now he is interested in finding the product on which he spent the largest amount of money. 
If there are products that cost the same amount of money, he'd like to find the one with the lexicographically smallest name.
The list of expenses is stored in a table Products which has the following columns:
id: unique product id;
name: the unique name of the product;
price: the price for one item;
quantity: the number of items bought.
The resulting table should contain one row with a single column: the product with the lexicographically smallest name on which Mr. Cash spent the largest amount of money.
The total amount of money spent on a product is calculated as price * quantity.

						CREATE PROCEDURE mostExpensive()
						BEGIN
							SELECT name FROM Products ORDER BY price * quantity DESC, name LIMIT 1;
						END
						
You are working as a recruiter at a big IT company, and you're actively looking for candidates who take the top places in major programming contests. 
Since the grand finale of the annual City Competition, you've been reaching out to the top participants from the leaderboard, and successfully so.
You have already interviewed all the prize winners (the top 3 participants), but that's not enough right now. 
Your company needs more specialists, so now you would like to connect with the participants who took the next 5 places.
The contest leaderboard is stored in a table leaderboard with the following columns:
id: unique id of the participant;
name: the name of the participant;
score: the score the participant achieved in the competition.
The resulting table should contain the names of the participants who took the 4th to 8th places inclusive, sorted in descending order of their places. 
If there are fewer than 8 participants, the results should contain those who ranked lower than 3rd place.
It is guaranteed that there are at least 3 prize winners in the leaderboard and that all participants have different scores.

						CREATE PROCEDURE contestLeaderboard()
						BEGIN
							SELECT name FROM leaderboard ORDER BY score DESC LIMIT 3, 5;
						END
						
At the end of every semester your professor for "Introduction to Databases" saves the exam results of every student in a simple database system. In the database table Grades, there are five columns:
Name: the name of the student;
ID: the student's ID number (a 5 byte positive integer);
Midterm1: the result of the first midterm out of 100 points;
Midterm2: the result of the second midterm out of 100 points;
Final: the result of the final exam, this time out of a possible 200 points.
According to school policy, there are three possible ways to evaluate a grade:
Option 1:
Midterm 1: 25% of the grade
Midterm 2: 25% of the grade
Final exam: 50% of the grade
Option 2:
Midterm 1: 50% of the grade
Midterm 2: 50% of the grade
Option 3:
Final exam: 100% of the grade.
Each student's final grade comes from the option that works the best for that student.
As a Teaching Assistant (TA), you need to query the name and id of all the students whose best grade comes from Option 3, sorted based on the first 3 characters of their name. 
If the first 3 characters of two names are the same, then the student with the lower ID value comes first.

						CREATE PROCEDURE gradeDistribution()
						BEGIN
							SELECT Name, ID From Grades WHERE Final > Midterm1 * 0.25 + Midterm2 * 0.25 + Final * 0.5 AND Final > Midterm1 * 0.5 + Midterm2 * 0.5 ORDER BY LEFT(name, 3);  
						END
						
Your nephews Huey, Dewey, and Louie are staying with you over the winter holidays. Ever since they arrived, you've hardly had a day go by without some kind of incident - the little rascals do whatever they please! 
Actually, you're not even mad; the ideas they come up with are pretty amazing, and it looks like there's even a system to their mischief.
You decided to track and analyze their behavior, so you created the mischief table in your local database. The table has the following columns:
mischief_date: the date of the mischief (of the date type);
author: the nephew who caused the mischief ("Huey", "Dewey" or "Louie");
title: the title of the mischief.
It looks like each of your nephews is active on a specific day of the week. You decide to check your theory by creating another table as follows:
The resulting table should contain four columns, weekday, mischief_date, author, and title, where weekday is the weekday of mischief_date (0 for Monday, 1 for Tuesday, and so on, with 6 for Sunday). 
The table should be sorted by the weekday column, and for each weekday Huey's mischief should go first, Dewey's should go next, and Louie's should go last. In case of a tie, mischief_date should be a tie-breaker. 
If there's still a tie, the record with the lexicographically smallest title should go first.
It is guaranteed that all entries of mischief are unique.

						CREATE PROCEDURE mischievousNephews()
						BEGIN
							SELECT WEEKDAY(mischief_date) AS weekday, mischief_date, author, title FROM mischief ORDER BY weekday, FIELD(author, "Huey", "Dewey", "Louie"), mischief_date, title;
						END
						
A large amount of money was stolen today from the main city bank, and as the chief of police it's your duty to find the robber.
You store information about your suspects in the table Suspect, which has the structure:
id: unique suspect id;
name: suspect first name;
surname: suspect surname;
height: suspect height;
weight: suspect weight.
You have already gathered some evidence and discovered the following clues:
according to the camera records, the robber is not taller than 170cm;
the robber left their signature near the crime scene: "B. Gre?n". "B" definitely stands for the first letter of robber's name, and "Gre?n" is their surname. 
The 4th letter of the surname is smudged by ketchup and is unreadable.
To make the list of suspects smaller, you would like to filter out the suspects who can't possibly be guilty according to the information obtained from the clues. 
For each remaining suspect, you want to save his/her id, name and surname. Please note that the information obtained from the clue should be considered case-insensitive, 
so for example "bill Green", and "Bill green", and "Bill Green" should all be included in the new table.
Given the table Suspect, build the resulting table as follows: the table should have columns id, name and surname and its values should be ordered by the suspects' ids in ascending order.

						CREATE PROCEDURE suspectsInvestigation()
						BEGIN
							SELECT id, name, surname FROM Suspect WHERE height <= 170 AND LOWER(name) LIKE LOWER("B%") AND LOWER(surname) LIKE LOWER("Gre_n");
						END

A large amount of money was stolen today from the main city bank, and as the chief of police it's your duty to find the robber.
You store information about your suspects in the table Suspect, which has the structure:
id: unique suspect id;
name: suspect first name;
surname: suspect surname;
height: suspect height;
weight: suspect weight.
You have already gathered some evidence and discovered the following clues:

according to the camera records, the robber is taller than 170cm;
the robber left their signature near the crime scene: "B. Gre?n". "B" definitely stands for the first letter of robber's name, and "Gre?n" is their surname. 
The 4th letter of the surname is smudged by ketchup and is unreadable.
The clues you've obtained allow you to let some suspects go since they can't possibly be guilty, so now you need to build a list that contains the people who can be freed based on the gathered information. 
For each of these people, you need to know his/her id, name and surname. Please note that the information obtained from the clue should be considered case-insensitive, 
so for example "bill Green", "Bill GrEeN", and "Bill Green" should all be included in the new table.
Given the table Suspect, build the resulting table as follows: the table should have columns id, name and surname and its values should be ordered by the suspects' ids in ascending order.

						CREATE PROCEDURE suspectsInvestigation2()
						BEGIN
							SELECT id, name, surname FROM Suspect WHERE height <= 170 OR LOWER(name) NOT LIKE LOWER("B%") OR LOWER(surname) NOT LIKE LOWER("Gre_n") ORDER BY id ASC;
						END